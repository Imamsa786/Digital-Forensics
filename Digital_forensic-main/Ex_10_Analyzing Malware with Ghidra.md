# Use Ghidra to Disassemble and Analyze the Malware Code

# Aim:

To perform static malware analysis using Ghidra, disassembling and decompiling a binary to understand its internal structure, identify malicious behaviors, and recognize potential persistence or anti-analysis techniques.


# Description:

Ghidra is an open-source reverse engineering tool developed by the National Security Agency (NSA) for analyzing executable files. It allows investigators to disassemble, decompile, and inspect compiled programs to uncover their functionality. In digital forensics, Ghidra is essential for analyzing malware binaries to identify hidden behaviors such as registry modifications, network connections, and file manipulations. This experiment focuses on using Ghidra to safely examine a sample binary and interpret its functionality within a controlled environment.

# Tools Required:
Ghidra (installed and configured with Java Development Kit - JDK)
Virtual Machine (VM) such as VirtualBox or VMWare for isolated analysis
Sample Binary (benign executable or controlled malware sample)
Operating System: Windows or Linux
Internet Connection (optional, for reference lookups)

# Procedure:
Step 1: Environment Setup

Install Ghidra on a secure system or a virtual machine.

Ensure Java JDK is properly installed and configured.

Prepare a safe sample binary (benign or test malware).

### Step 2: Launch Ghidra

Open Ghidra and create a new project (Non-Shared Project).

Enter a project name such as “Malware_Analysis_Case01”.

Import the sample binary into the project.
### Step 3: Run Auto-Analysis

Once the binary is loaded, Ghidra prompts for Auto-Analysis.

Enable the recommended analyzers and click Analyze.

Ghidra automatically disassembles the binary and identifies key functions, data references, and entry points.

### Step 4: Examine the Code Structure

Open the Listing Window to view the disassembled assembly code.

Use the Decompiler Window to view high-level C-like pseudocode for easier interpretation.

Identify the main() or entry function to understand program flow.


### Step 5: Analyze Functions and Strings

Open the Defined Strings window to locate readable text (URLs, IPs, registry keys, etc.).

Examine Imported Functions under the Imports tab (e.g., CreateFileA, URLDownloadToFile, RegSetValueEx).

Rename and comment on suspicious functions for clarity.

### Step 6: Trace Function References

Use Cross-References (XREFs) to trace where specific functions or variables are used.

Build an understanding of how data flows through the program (e.g., encryption, persistence).

### Step 7: Visualize Control Flow

Open the Control Flow Graph (CFG) view to visualize how the program executes.

Identify loops, branches, or conditional checks that indicate malware logic such as sandbox evasion or delayed execution.

### Step 8: Document Findings

Summarize your observations in a structured report.

Highlight suspicious functions, API calls, or strings.

Document behavioral indicators such as persistence, data exfiltration, or file modifications.

# Result:
The malware analysis was successfully performed using Ghidra. The binary was disassembled and decompiled to reveal its internal logic and behavior. Critical functions, suspicious strings, and system interaction patterns were identified. The experiment demonstrated how Ghidra aids in understanding malware structure, detecting persistence mechanisms, and uncovering potential malicious intent through static analysis.
